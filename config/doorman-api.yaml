# API: Home Assistant

api:
  batch_delay: 0ms
  custom_services: true
  homeassistant_services: true
  actions:
    - action: send_tc_telegram_raw
      variables:
        telegram: string
      then:
        - if:
            condition:
              lambda: 'return telegram.length() == 4 || telegram.length() == 8;'
            then:
              - tc_bus.send:
                  telegram: !lambda |-
                    size_t pos;
                    uint32_t value = std::stoul(telegram, &pos, 16);
                    if (pos != telegram.length()) {
                        return 0;
                    }
                    return value;
                  is_long: !lambda |-
                    return telegram.length() == 8;
              - api.respond:
                  success: true
            else:
              - api.respond:
                  success: false
                  error_message: "Telegram length must be either 4 or 8!"

    - action: send_tc_telegram
      variables:
        type: string
        address: int
        payload: int
        serial_number: int
      then:
        - tc_bus.send:
            type: !lambda 'return string_to_telegram_type(type.c_str());'
            address: !lambda 'return address;'
            payload: !lambda 'return payload;'
            serial_number: !lambda 'return serial_number;'
        - api.respond:
            success: true

    - action: send_tc_is_telegram
      variables:
        type: string
        address: int
        payload: int
      then:
        - tc_bus_device.send:
            id: tc_bus_indoor_station
            type: !lambda 'return string_to_telegram_type(type.c_str());'
            address: !lambda 'return address;'
            payload: !lambda 'return payload;'
        - api.respond:
            success: true

    - action: reconfigure_wifi
      variables:
        ssid: string
        password: string
      then:
        - wifi.configure:
            ssid: !lambda 'return ssid;'
            password: !lambda 'return password;'
            save: true

tc_bus:
  on_telegram:
    - homeassistant.event:
        event: esphome.doorman
        data_template:
          telegram: "{{ telegram }}"
          type: "{{ type }}"
          address: "{{ address }}"
          payload: "{{ payload }}"
          serial_number: "{{ serial_number }}"
        variables:
          telegram: !lambda |-
            static char buf[9];
            memcpy(buf, x.hex, 9);
            return buf;
          type: !lambda return telegram_type_to_string(x.type);
          address: !lambda return x.address;
          payload: !lambda return x.payload;
          serial_number: !lambda return x.serial_number;

script:
  - id: !extend boot_state
    then:
      # WiFi already connected
      - if:
          condition:
            api.connected:
              state_subscription_only: true
          then:
            - logger.log: "LED: Home Assistant API already connected"
          else:
            - logger.log: "LED: Waiting for Home Assistant API connection"
            - light.turn_on:
                id: doorman_rgb_status_led
                effect: slow_pulse
                red: 0%
                green: 22%
                blue: 100%
            - wait_until:
                condition:
                  api.connected:
                    state_subscription_only: true
            - logger.log: "LED: API connected"
            - light.turn_on:
                id: doorman_rgb_status_led
                effect: none
                red: 0%
                green: 22%
                blue: 100%
                #transition_length: 1s
                brightness: !lambda return id(doorman_rgb_status_led_brightness).state / 100.0;
            - delay: 3s

      # Update LED state
      - script.execute: update_led